
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    {
      "Generic skeleton": {
        "prefix": "gen skel",
        "body": [
"// <-------------------------------------------Libraries------------------------------------>",
"#include <iostream>",
"#include <cstdio>",
"#include <cstring>",
"#include <cmath>",
"#include <algorithm>",
"#include <vector>",
"#include <set>",
"#include <map>",
"#include <unordered_map>",
"#include <unordered_set>",
"#include <queue>",
"#include <stack>",
"#include <bitset>",
"#include <list>",
"#include <string>",
"#include <utility>",
"#include <cassert>",
"#include <limits>",
"#include <numeric>",
"#include <functional>",
"#include <iomanip>",
"#include <sstream>",
"#include <climits>",
"#include <cstdlib>",
"#include <ctime>",
"#include <array>",
"#include <cstdint>",
"#include <chrono>",
"#include <ext/pb_ds/assoc_container.hpp>",
"#include <ext/pb_ds/tree_policy.hpp>",
"// <--------------------------------Libraries end------------------------------------------------>",
"",
"using namespace std;",
"using namespace __gnu_pbds;",
"",
"// <------------------------------------Debugging Macros for Conditional Output during Development---------------------------------->",
"#ifndef ONLINE_JUDGE",
"    #define debug(x)        cerr << #x << \" = \" << (x) << \"\\n\"",
"    #define debug_pair(p)   cerr << #p << \" = (\" << (p).first << \", \" << (p).second << \")\\n\"",
"    #define debug_vec(v)    do {                                          \\",
"                             cerr << #v << \" = [\";                       \\",
"                             for (auto& _e : (v))                       \\",
"                                 cerr << _e << \", \";                      \\",
"                             cerr << \"]\\n\";                              \\",
"                          } while (0)",
"    #define debug_map(m)    do {                                          \\",
"                             cerr << #m << \" = {\";                       \\",
"                             for (auto& _kv : (m))                      \\",
"                                 cerr << \"(\" << _kv.first                \\",
"                                      << \":\" << _kv.second << \"), \";      \\",
"                             cerr << \"}\\n\";                              \\",
"                          } while (0)",
"#else",
"    #define debug(x)        do {} while (0)",
"    #define debug_pair(p)   do {} while (0)",
"    #define debug_vec(v)    do {} while (0)",
"    #define debug_map(m)    do {} while (0)",
"#endif",
"// <------------------------------------------------------Debugging ends --------------------------------------------------------->",
"",
    "#define FAST_IO do{ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);}while(0)",
    "#define FORI for (int i = 0; i < n; i++)",
    "#define FORJ for (int j = 0; j < n; j++)",
    "#define FOR(a, b, x) for (int a = b; a < x; a++)",
    "#define VOUT for(auto it:nums){ cout << it; }",
    "#define pb emplace_back",
    "#define all(x) x.begin(), x.end()",
    "#define int int64_t",
    "#define ld long double",
    "using i64 = int64_t;",
    "using i128 = __int128_t;",
    "#define lb lower_bound",
    "#define ub upper_bound",
    "#define min_heap priority_queue<int, vector<int>, greater<int>>",
    "#define min_heap_pair priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>",
    "#define minh_heap_tuple priority_queue<tuple<ll,int,int>,vector<tuple<ll,int,int>>,greater<tuple<ll,int,int>>>",    
    "#define py cout<<\"YES\"<<endl",
    "#define pn cout<<\"NO\"<<endl",
    "#define endl \"\\n\"",
    "#define ps(x,y) fixed<<setprecision(y)<<x",
    "#define numtobin(n) bitset<32>(n).to_string()",
    "#define vi vector<int>",
    "#define vll vector<long long>",
    "#define vvi vector<vector<int>>",
    "#define vb vector<bool>",
    "#define vc vector<char>",
    "#define vs vector<string>",
    "#define pii pair<int,int>",
    "#define vpii vector<pair<int,int>>",
    "#define si set<int>",
    "#define ff first",
    "#define ss second",
    "#define POPCOUNT(x) (__builtin_popcountll(x)) // counts number of 1 / set bits in x ",
    "#define CLZ(x) (__builtin_clzll(x))           // counts leading 0s in x (before first 1 from MSB)",
    "#define CTZ(x) (__builtin_ctzll(x))           // counts trailing 0s in x (after last 1 from LSB)",
    "using ll = long long;",
    "const ll mod = 1e9 + 7;",
    "const int INF = 1e15;",
    "",
"// <-------------------------Modular Arithmetic Utility Functions-------------------------------->",
"ll mod_pow(ll a, ll b, ll m = mod) {",
"    ll res = 1;",
"    while (b) {",
"        if (b & 1) res = (res * a) % m;",
"        a = (a * a) % m;",
"        b >>= 1;",
"    }",
"    return res;",
"}",
"",
"ll mod_inv(ll a, ll m = mod) {",
"    return mod_pow(a, m - 2, m);",
"}",
"",
"ll mod_add(ll a, ll b, ll m = mod) {",
"    return ((a % m + b % m) % m + m) % m;",
"}",
"",
"ll mod_sub(ll a, ll b, ll m = mod) {",
"    return ((a % m - b % m) % m + m) % m;",
"}",
"",
"ll mod_mul(ll a, ll b, ll m = mod) {",
"    return ((a % m) * (b % m)) % m;",
"}",
"",
"ll mod_div(ll a, ll b, ll m = mod) {",
"    return mod_mul(a, mod_inv(b, m), m);",
"}",
"// <-----------------------------------Predefined Functions-------------------------------------------------------->",
"",
"bool isPrime(ll n) {",
"    if (n <= 1) return false;",
"    for (ll i = 2; i * i <= n; ++i)",
"        if (n % i == 0) return false;",
"    return true;",
"}",
"",
"vector<ll> primefactors(ll n) {",
"    vector<ll> fac;",
"    for (ll x = 2; x * x <= n; ++x) {",
"        while (n % x == 0) {",
"            fac.pb(x);",
"            n /= x;",
"        }",
"    }",
"    if (n > 1) fac.pb(n);",
"    return fac;",
"}",
"",
"ll gcd(ll a, ll b) {",
"    return b ? gcd(b, a % b) : a;",
"}",
"",
"ll lcm(ll a, ll b) {",
"    return (a / gcd(a, b)) * b;",
"}",
"",
"bool isPowerOfTwo(ll n) {",
"    return n > 0 && (n & (n - 1)) == 0;",
"}",
"",
"bool isPerfectSquare(ll x) {",
"    if (x < 0) return false;",
"    ll r = sqrtl(x);",
"    return r * r == x;",
"}",
"",
"vector<bool> SieveOfEratosthenes(ll n) {",
"    vector<bool> prime(n + 1, true);",
"    prime[0] = prime[1] = false;",
"    for (ll p = 2; p * p <= n; ++p) {",
"        if (prime[p]) {",
"            for (ll i = p * p; i <= n; i += p)",
"                prime[i] = false;",
"        }",
"    }",
"    return prime;",
"}",
"",
"// <----------------------------------------Templates------------------------------------------------>",
    "template <typename T>",
    "T floor(T a, T b) {",
    "    return a / b - (a % b && (a ^ b) < 0);",
    "}",
    "template <typename T>",
    "T ceil(T x, T y) {",
    "    return floor(x + y - 1, y);",
    "}",
    "template <typename T>",
    "bool has_kth_bit(T x, int k) {",
    "    return x >> k & 1;",
    "}",
    "template <typename T>",
    "struct Compare {",
    "    bool operator()(const pair<T, T>& p1, const pair<T, T>& p2) {",
    "        if (p1.first == p2.first) {",
    "            return p1.second > p2.second;",
    "        }",
    "        return p1.first > p2.first;",
    "    }",
    "};",
    "// <---------------------------------------Templates end------------------------------------------------>",
"// Ordered Set",
"// Use find_by_order(k) to get an iterator to the k-th (0-indexed) smallest element",
"// Use order_of_key(k) to get count of elements < x",
"template <typename T>",
"using ordered_set = tree<",
"T,",
"null_type,",
"less<T>,",
"rb_tree_tag,",
"tree_order_statistics_node_update>;",
"",
"// Custom hash function",
"struct custom_hash {",
"    static uint64_t splitmix64(uint64_t x) noexcept {",
"        x += 0x9e3779b97f4a7c15ULL;",
"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9ULL;",
"        x = (x ^ (x >> 27)) * 0x94d049bb133111ebULL;",
"        return x ^ (x >> 31);",
"    }",
"",
"    // base uint64_t entrypoint",
"    size_t operator()(uint64_t x) const noexcept {",
"        static const uint64_t FIXED_RANDOM =",
"            chrono::steady_clock::now().time_since_epoch().count();",
"        return (size_t)splitmix64(x + FIXED_RANDOM);",
"    }",
"",
"    // generic fallback for types that have std::hash<T>",
"    template<typename T>",
"    size_t operator()(const T &x) const noexcept {",
"        return (*this)(static_cast<uint64_t>(std::hash<T>{}(x)));",
"    }",
"",
"    // pair<K,V> overload (so pair<int,int> works even though std::hash<pair<..>> is not standard)",
"    template<typename A, typename B>",
"    size_t operator()(const pair<A,B> &p) const noexcept {",
"        uint64_t h1 = uint64_t(std::hash<A>{}(p.first));",
"        uint64_t h2 = uint64_t(std::hash<B>{}(p.second));",
"        // combine like boost::hash_combine, then feed to splitmix",
"        uint64_t combined = h1 ^ (h2 + 0x9e3779b97f4a7c15ULL + (h1<<6) + (h1>>2));",
"        return (*this)(combined);",
"    }",
"};",
"",
"template<typename K, typename V>",
"using umap = unordered_map<K, V, custom_hash>;",
"// <---------------------------------------Templates end------------------------------------------------>",
"",
"// Problem Statement :",
"/*",
"   ",
"*/",
"",
"// Observation :",
"/*",
"   ",
"*/",
"",
"// Claims on the solution :", 
"/*",  
"   ",
"*/",
"",
"void solve() {",
"",
"$2",
"",
"}",
"",
"int32_t main() {",
"",
"// #ifndef ONLINE_JUDGE",
"// freopen(\"input.txt\", \"r\", stdin);",
"// freopen(\"output.txt\", \"w\", stdout);",
"// #endif",
"",
"    FAST_IO;",
"    int t;",
"    t = 1;",
"    cin >> t;",
"    while (t--) {",
"        solve();",
"    }",
"    return 0;",
"}",
        ],
        "description": "Generic skeleton of a C++ program."
      },
      "peuler": {
        "prefix": "peuler",
        "body": [
    "// <-------------------------------------------Libraries------------------------------------>",
    "#include <iostream>",
    "#include <cstdio>",
    "#include <cstring>",
    "#include <cmath>",
    "#include <algorithm>",
    "#include <vector>",
    "#include <set>",
    "#include <map>",
    "#include <unordered_map>",
    "#include <unordered_set>",
    "#include <queue>",
    "#include <stack>",
    "#include <bitset>",
    "#include <list>",
    "#include <string>",
    "#include <utility>",
    "#include <cassert>",
    "#include <limits>",
    "#include <numeric>",
    "#include <functional>",
    "#include <iomanip>",
    "#include <sstream>",
    "#include <climits>",
    "#include <cstdlib>",
    "#include <ctime>",
    "#include <array>",
    "#include <cstdint>",
    "#include <chrono>",
    "// #include <ext/pb_ds/assoc_container.hpp>",
    "// #include <ext/pb_ds/tree_policy.hpp>",
    "// <--------------------------------Libraries end------------------------------------------------>",
    " ",
    "using namespace std;",
    "",
    "// <------------------------------------Debugging Macros for Conditional Output during Development---------------------------------->",
    "#ifndef ONLINE_JUDGE",
    "  #define debug(x)        cerr << #x << \" = \" << (x) << \"\\n\"",
    "  #define debug_pair(p)   cerr << #p << \" = (\" << (p).first << \", \" << (p).second << \")\\n\"",
    "  #define debug_vec(v)    do {                                ",
    "                             cerr << #v << \" = [\";             ",
    "                             for (auto& _e: (v))              ",
    "                               cerr << _e << \", \";            ",
    "                             cerr << \"]\\n\";                    ",
    "                          } while (0)",
    "  #define debug_map(m)    do {                                ",
    "                             cerr << #m << \" = {\";             ",
    "                             for (auto& _kv: (m))              ",
    "                               cerr << \"(\"                       ",
    "                                    << _kv.first << \":\"         ",
    "                                    << _kv.second << \"), \";    ",
    "                             cerr << \"}\\n\";                    ",
    "                          } while (0)",
    "#else",
    "  #define debug(x)        do {} while (0)",
    "  #define debug_pair(p)   do {} while (0)",
    "  #define debug_vec(v)    do {} while (0)",
    "  #define debug_map(m)    do {} while (0)",
    "#endif",
    "// <------------------------------------------------------Debugging ends --------------------------------------------------------->",
    "",
    "#define ya ios_base::sync_with_stdio(false);",
    "#define sudi cin.tie(nullptr);",
    "#define balle_balle cout.tie(nullptr);",
    "#define FORI for (int i = 0; i < n; i++)",
    "#define FORJ for (int j = 0; j < n; j++)",
    "#define FOR(a,x) for (int a = 0; a < x; a++)",
    "#define VOUT for(auto it:nums){ cout << it; }",
    "#define push_back emplace_back",
    "#define pb emplace_back",
    "#define all(v) v.begin(), v.end()",
    "#define int long long",
    "#define lb lower_bound",
    "#define ub upper_bound",
    "#define min_heap priority_queue<int, vector<int>, greater<int>>",
    "#define min_heap_pair priority_queue<pair<int, int>, vector<pair<int, int>>, Compare<int>>",
    "#define py cout<<\"YES\"<<endl",
    "#define pn cout<<\"NO\"<<endl",
    "#define endl \"\\n\"",
    "#define ps(x,y) fixed<<setprecision(y)<<x",
    "#define numtobin(n) bitset<32>(n).to_string()",
    "typedef long long ll;",
    "const ll mod = 1e9 + 7;",
    "const int INF = 1e15;",
    " ",
    "// <-------------------------Modular Arithmetic Utility Functions-------------------------------->",
    "ll mod_pow(ll a, ll b, ll m = mod) {ll res = 1;while (b > 0) {if (b & 1)res = (res * a) % m;a = (a * a) % m;b = b >> 1;}return res;}",
    "ll mod_inv(ll a, ll m = mod) { return mod_pow(a, m - 2, m); }",
    "ll mod_add(ll a, ll b, ll m = mod) { a %= m; b %= m; return (((a + b) % m) + m) % m; }",
    "ll mod_sub(ll a, ll b, ll m = mod) { a %= m; b %= m; return (((a - b) % m) + m) % m; }",
    "ll mod_mul(ll a, ll b, ll m = mod) { a %= m; b %= m; return (((a * b) % m) + m) % m; }",
    "ll mod_div(ll a, ll b, ll m = mod) { a %= m; b %= m; return mod_mul(a, mod_inv(b, m), m); }",
    "",
    "// <-----------------------------------Predefined Functions-------------------------------------------------------->",
    "#define isPrime(n) ([](int num){ if(num <= 1) return false; for(int i=2; i*i <= num; ++i) if(num % i == 0) return false; return true; }(n))",
    "#define primef vector<int> factors(int n) { vector<int> f; for (int x = 2; x*x <= n; x++) { while (n % x == 0) { f.push_back(x); n /= x; } } if (n > 1) f.push_back(n); return f; }",
    "ll gcd(ll a, ll b) { while(b) { a %= b; swap(a, b); } return a; }",
    "ll lcm(ll a, ll b) { return (a / gcd(a, b)) * b; }",
    "bool isPowerOfTwo(int n) { if(n == 0) return false; return (ceil(log2(n)) == floor(log2(n))); }",
    "bool isPerfectSquare(ll x) { return x >= 0 && static_cast<ll>(sqrt(x)) * static_cast<ll>(sqrt(x)) == x; }",
    "vector<bool> SieveOfEratosthenes(ll n) {",
    "    vector<bool> prime(n+1, true);",
    "    prime[0] = prime[1] = false;",
    "    for(ll p = 2; p*p <= n; p++) {",
    "        if(prime[p]) {",
    "            for(ll i = p*p; i <= n; i += p) {",
    "                prime[i] = false;",
    "            }",
    "        }",
    "    }",
    "    return prime;",
    "}",
    "// Custom hash function ",
    "struct custom_hash {",
    "    static uint64_t splitmix64(uint64_t x) {",
    "        x += 0x9e3779b97f4a7c15;",
    "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
    "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
    "        return x ^ (x >> 31);",
    "    }",
    "    size_t operator()(uint64_t x) const {",
    "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
    "        return splitmix64(x + FIXED_RANDOM);",
    "    }",
    "};",
    "template<typename K, typename V> // Use safe_umap <int,int> to declare this hashmap",
    "using safe_umap = unordered_map<K, V, custom_hash>;",
    "",
    "// <----------------------------------------Templates------------------------------------------------>",
    "template <typename T>",
    "T floor(T a, T b) {",
    "    return a / b - (a % b && (a ^ b) < 0);",
    "}",
    "template <typename T>",
    "T ceil(T x, T y) {",
    "    return floor(x + y - 1, y);",
    "}",
    "template <typename T>",
    "bool has_kth_bit(T x, int k) {",
    "    return x >> k & 1;",
    "}",
    "template <typename T>",
    "struct Compare {",
    "    bool operator()(const pair<T, T>& p1, const pair<T, T>& p2) {",
    "        if (p1.first == p2.first) {",
    "            return p1.second > p2.second;",
    "        }",
    "        return p1.first > p2.first;",
    "    }",
    "};",
    "// <---------------------------------------Templates end------------------------------------------------>",
    "",
    "void solve() {",
    "",
    "$2",
    "",
    "}",
    "",
    "int32_t main() {",
    "    ya sudi balle_balle",
    "        solve();",
    "    return 0;",
    "}",
        ],
        "description": "Generic skeleton of a C++ program."
      },
    "clean code": {
        "prefix": "clean",
        "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "#define int long long",
    "",
    "// Problem Statement :",
    "/*",
    "    ",
    "*/",
    "",
    "// Editorial :",
    "/*",
    "    ",
    "*/",
    "",
    "void solve() {",
    "",
    "    $2",
    "",
    "}",
    "",
    "int32_t main() {",
    "    ios_base::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "    cout.tie(nullptr);",
    "",
    "    int t = 1;",
    "    cin >> t;",
    "    while (t--)",
    "    solve();",
    "",
    "    return 0;",
    "}",
    ""
  ],
  "description": "Basic generic skeleton for cp"
},
"Luffy comment": {
"prefix": "luffy",
"body": [
  "/*",
  "⣿⣻⣿⣿⡟⠀⠀⠀⠀⠀⠀⢀⣴⣿⡿⢟⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢫⣊⣽⣵⠖⠀⠻⣿⣿⣿⣿⣿⣿⣯⢻⣿⣷⠀⠀⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⣐⢣",
"⣿⣷⣻⣿⠁⠀⠀⠀⠀⠀⣰⣿⠟⠉⢐⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠜⣫⣿⢯⡞⠀⠀⠹⣿⣿⣿⣿⣿⣿⠀⢿⣿⡄⣀⣴⣟⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠈⠂⠀⠀⠀⠀⠀⠀⠀⢆⢧",
"⣿⣿⣷⠉⠀⠀⠀⠀⢀⡾⠋⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣇⣴⢏⣵⢏⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⠀⠈⢿⣧⠓⢉⣯⢧⢿⣿⣿⣿⣿⠌⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⡜⣎",
"⣿⣿⣿⠀⠀⠀⠀⠀⠋⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⠇⣼⣷⠟⠁⠀⢀⡴⢃⠀⠹⣿⣿⣿⣿⡃⠀⠈⣿⡔⠋⣡⢣⣾⠿⣿⣿⣿⡃⢸⣿⣿⣿⣿⣿⣿⣿⣿⣷⡈⢻⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠜⣲",
"⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⢀⢮⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣗⣿⣿⣿⠾⠋⠁⠀⣠⢞⡿⡵⡻⣂⠀⢹⣿⣿⣿⡇⠀⣴⡻⣷⣔⣯⢾⠵⢫⢿⣿⣿⠅⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠙⢿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⣸⡱",
"⣞⣿⡃⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⢟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢨⡗⣿⣿⠀⠀⠀⠈⠙⢫⢋⣼⣿⡛⠀⠀⢻⣿⣿⡆⠀⠙⣡⣼⣾⢜⣣⢔⣵⣫⣿⣿⡁⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠻⣿⠀⠀⠀⠀⠀⠀⠀⠀⠰⢨⣱⢹",
"⣿⠼⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⡿⠟⠁⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠈⠀⢻⣿⢀⣀⣀⣀⠤⢤⣉⣁⠈⠛⠃⠀⠘⣿⣿⠇⠀⠀⠀⠀⣈⣧⣉⣛⣑⣛⡍⢿⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠚⣧⠀⠀⠀⠀⠀⠀⢀⢃⠳⣬⠳",
"⣿⠃⠀⠀⠀⠀⠀⠀⢀⣾⠟⠋⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠐⠒⢻⣿⠁⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⡹⣿⡃⠀⠀⠉⠉⠁⠀⠀⠀⠀⠀⠈⠹⠉⠓⠂⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠑⠀⠀⠀⠀⠀⠄⣎⢳⡜⡳",
"⣿⠁⠀⠀⠀⠀⠀⠀⠋⠁⠀⠀⠀⢀⢼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡗⠀⠀⠈⣿⣀⡤⠠⠄⠤⣀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠅⢠⠄⠀⠀⣴⣒⠶⠭⠤⢄⣀⡀⠀⠀⠀⢸⡏⢿⣿⣿⣿⣿⣿⣿⣿⠈⠻⣿⣷⣄⠀⠀⠀⠀⠀⢀⡚⣬⢳⣚⠵",
"⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡌⢢⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⢀⣨⣟⠶⠶⠉⠛⠓⠭⣍⣉⠒⠀⠀⠀⠀⠀⠸⠇⡞⠀⢒⡩⢕⡒⠐⠂⠒⠒⠒⠪⢅⡀⠀⢸⠀⢸⣿⣿⣿⣿⣿⣿⣿⡇⠀⠈⠙⢿⣮⣢⣄⠀⡐⢬⡺⡵⣏⢮⡓",
"⡗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⡄⣻⣿⣿⣿⡿⣻⣿⣿⣿⣿⣿⣿⢻⣿⣿⡇⣠⠟⣉⣀⣀⣀⡠⠄⣀⣀⠈⡙⠻⠄⠀⠀⠀⢀⣴⢿⠃⢰⣟⠫⠥⠤⠠⢠⣤⠠⠤⠤⣀⡉⠂⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠈⠪⠝⠿⣽⣰⢣⣟⡽⣎⠷⡡",
"⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡘⢰⣻⣿⣿⡟⠁⣿⣿⣿⣿⣿⣿⣿⠈⣿⣿⡟⠫⠥⠤⠤⠼⠿⠧⠤⠔⢒⡋⠁⠀⠀⠀⠀⠀⠉⣼⣻⠀⠘⠫⢔⣒⡒⠠⠼⢟⢣⢖⣒⠒⠋⠁⢀⠀⢨⣿⣿⣿⣿⡝⣿⣿⣿⠀⠀⢀⠠⡐⣋⠖⣼⣻⠿⣼⢯⡝⣧⠑",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡱⠌⣿⣿⡟⠀⢸⣿⣿⣿⣿⣿⣿⣿⡀⢹⣿⡗⠈⠓⠒⠒⠒⠒⠒⠲⠟⠛⢉⣵⡦⣶⠀⠀⠀⠀⠉⣟⠀⠀⠙⠒⠒⠠⠍⠻⡤⠂⠒⠲⡖⠋⠉⠉⠀⢸⣿⣿⣿⣿⡇⠸⣿⣿⡃⠰⣌⠲⡱⡜⣾⣱⢯⡿⡽⣾⡹⢆⡍",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢑⡀⣿⡟⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⢿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠟⠁⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠀⠀⠉⠀⠀⠀⠀⣾⣿⣿⣿⣿⣷⢐⢻⣿⣇⠳⣌⡳⣽⣹⢾⣽⢯⡿⣽⢶⡛⢦⠐",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢢⠀⣿⠁⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠸⢿⠀⠀⣀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠹⠰⢤⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⢻⣿⣿⣿⣿⣿⣎⡽⣿⣧⣛⡼⣳⢷⣯⡿⣯⡿⣽⡳⣯⢝⠢⡁",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡠⢈⠃⢠⣾⡿⠋⢁⣿⣿⣿⡿⣿⣿⣷⠀⠀⠈⣀⣼⣥⢞⣅⠀⠀⠀⠀⠀⠀⡰⠋⢉⣉⡀⠀⠀⠀⠀⢀⣠⣀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡿⠿⠳⣿⣿⣷⣽⣻⡷⣾⢽⣯⣿⢾⣟⣷⣻⡗⣿⡱⣎⠱⡀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⢁⠂⣾⡿⠋⠀⠀⢸⣿⣽⢱⢲⡌⠻⣿⣇⢰⡾⣟⣷⡟⣫⠞⠀⠀⠀⠀⠀⠀⢧⡀⢾⣿⣿⠀⠀⠀⠠⣻⣿⡿⢂⡴⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡴⣾⢣⢹⣿⢿⡿⣟⡿⣽⣻⢾⣽⣻⢞⡷⣯⢟⡾⣱⢎⠱⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⠄⠁⠀⠀⠀⢀⠀⢻⢿⠀⢸⣽⣆⢹⡹⠀⢀⣼⣷⠿⣫⠀⡀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣯⣶⣿⠀⣾⣿⣻⣽⢿⣽⣳⣯⣟⡾⣽⢯⡿⣭⣟⣞⡳⢎⠢⠁",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⣈⠂⠄⠀⠀⠀⠈⠀⠀⢪⢧⠘⣧⣻⣀⡇⠀⠚⡡⢋⣴⡷⣻⡧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣼⡧⠏⣰⣿⣳⣟⡾⣯⣟⣷⣻⢾⡽⣯⢷⣻⣳⡽⢮⡝⢎⡰⠁",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠐⣄⠊⠄⠀⠀⠀⠀⠀⠀⠀⠩⡳⣀⠉⠙⠻⡄⠀⣵⣿⡯⣺⣿⡥⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢤⠋⢀⣠⢞⡏⢷⣛⡾⣽⣳⣟⡾⣽⢯⡿⣽⢯⣷⣻⡼⣻⡜⣡⠂⡁",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠌⡰⢈⠄⠀⠀⠀⠀⠀⠀⠀⠀⠉⡈⠳⢦⣄⣹⡄⠑⠋⠈⠙⠋⠓⠀⢀⣀⡤⠴⢖⡒⣒⢒⡒⣒⢒⡒⢖⠲⡒⢦⠤⣤⣄⣀⣀⠀⠀⠀⠀⠀⠀⣠⠞⢒⠫⡐⢊⠜⣢⢛⡼⢳⣛⡾⣽⢯⡿⣽⢯⣟⣾⣳⡽⣣⠟⡤⠁⠄",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⡑⢌⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡑⢢⠐⡀⠙⢦⡀⠀⠀⠀⠀⠐⠛⠓⠚⠓⠒⠓⠚⠒⠓⠞⠦⠙⠮⠱⠭⠖⠳⠴⠒⠦⠭⠟⠂⠀⠀⢀⡴⠃⠁⠀⠁⡘⠄⢊⢄⠣⢜⠣⣏⡽⣏⡿⣽⢯⣟⡾⣷⢯⣷⢫⣝⡰⢁⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⡑⢌⠂⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠢⠑⠄⠂⠀⠙⢦⡀⠀⠀⠀⠀⠀⠉⠒⠒⠦⠤⠤⠤⢀⣀⣀⠀⡀⣀⢀⡠⠤⠤⠀⠀⠀⠀⣠⠴⠋⠀⠀⠀⠀⠀⠀⠈⠀⠌⠒⡈⠱⢌⡚⣭⢻⣽⣻⢾⡽⣯⣟⡾⣝⢦⡑⢂⠀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠡⢈⠐⠀⠈⠐⣙⢳⡤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠴⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢁⠂⡱⢌⡻⣜⣯⠿⣽⣳⢯⡽⣞⢧⡙⠄⠂",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠜⣄⠊⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠄⠀⠁⢆⠣⣜⠢⡉⠙⣶⢦⣤⣄⣀⣀⣀⡀⣀⣀⣀⣀⣤⡤⠴⠒⠋⠍⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢀⠢⠱⣙⢮⢿⡽⢯⣻⡽⣝⡮⡕⢊⠄",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢭⠰⡈⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠈⢄⠫⡔⢣⠐⠀⢸⣎⡜⡹⢻⢿⣿⣿⣿⣿⣿⠟⣻⠁⠀⠀⠀⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⡌⢾⡹⣞⣯⢷⣻⡝⣾⣉⠆⡀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢊⠵⣁⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠈⡕⣪⢅⠊⠀⠸⡝⢶⣡⢃⡎⡜⣩⢫⡑⢦⣹⢾⠀⠀⠀⠀⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡰⣙⠾⣽⣞⣳⣻⠵⣍⠖⡀",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢜⡢⢅⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⠒⡥⣊⠔⠀⠀⡇⠀⠙⢶⣸⡰⢡⢆⣹⠖⠃⢸⠀⠀⠀⠀⡐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠡⠐⣩⢛⡼⣞⣳⣭⠿⣜⢣⠐",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢪⡜⡥⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡉⢖⡡⢊⠀⠀⡇⠀⠀⠀⠀⠉⠉⠉⠀⠀⠀⢸⠄⠀⠀⠀⠐⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠠⢋⡼⢭⣳⣭⢟⡼⢢⠁",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢡⢚⡴⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣢⢑⠢⠀⢀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⢸⡆⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠂⡜⢣⢗⣮⢻⣜⠣⠌",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⣈⠞⡴⣁⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⢎⡁⠂⢸⠃⠀⠀⠀⠀⠀⠀⠀⠀⣴⠇⠸⡇⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠡⠘⠤⣋⢼⡳⢮⣙⠂",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠡⣀⠻⡴⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⣌⣧⣘⡀⡟⠀⠀⠀⠀⠀⠀⠀⠀⣴⣿⠇⠀⢿⡂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢁⠂⡱⢪⣝⡳⣌⠣",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠁⠤⣛⠴⣁⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣾⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⣠⠞⣱⠗⣳⡄⠘⣧⣶⣶⣷⣶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⡁⠳⣌⠷⣭⠒",
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠤⢁⠲⣍⠷⣀⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠸⣾⠕⣹⣟⣴⠆⠘⢏⠙⢿⣿⡿⣿⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⠱⡌⣟⢶⡩",
"⠀⠀⠀⠀⠀⠀⠀⠀⠠⡘⢀⠲⣭⡳⡅⠀⠀⠀⠀⣠⣤⣤⣤⣤⣴⣶⣶⣿⣿⣿⣿⣿⣿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⣰⠟⡵⢃⣤⠏⡀⠓⠌⣻⣿⣟⣿⣿⣿⣿⣶⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠒⡸⢬⣳⢣",
"⠀⠀⠀⠀⠀⠀⠀⠀⠤⡑⠂⡜⣶⡻⡔⣁⡤⠤⠚⣿⣿⣿⣿⢿⣻⣿⣻⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠞⢡⡮⠔⢡⢫⡿⠃⠀⠀⠀⢿⣿⣻⣿⣿⢿⣿⡿⣿⣿⣿⣶⣶⣾⣶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠣⢏⡾⣱",
"⠀⠀⠀⠀⠀⠀⠀⢀⠢⢡⠁⣼⣳⠟⠋⠁⠀⠀⠀⣿⣿⣿⣿⣻⣿⣳⣿⣿⣻⣯⣿⡏⠒⠲⠤⠤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠰⢃⣉⡤⠤⠤⠴⠒⠚⣿⣿⣽⣿⣿⣿⣿⣟⣾⡿⣽⣿⢿⣿⣿⣷⠢⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣍⢺⡱⢧",
"⠀⠀⠀⠀⠀⠀⠀⢀⠎⣐⡶⠋⠀⠀⣀⠀⠀⠀⠀⢼⣿⣿⡿⣽⣷⣿⣿⣻⣽⣷⡿⠁⠀⠀⠀⠀⠀⠀⠙⢦⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠉⠀⠀⠀⠀⠀⠀⠀⢸⣿⣯⣿⣿⣿⣿⣿⣯⣿⣟⣯⣿⣿⣷⣿⡆⠀⠉⠲⢄⡀⠀⠀⠀⠀⠀⠀⣂⠧⡝⣧",
"⠀⠀⠀⠀⠀⠀⠀⢢⡼⠋⠀⢀⡠⠞⠁⠀⠀⠀⠀⣾⣿⣿⡿⣿⣽⣾⣟⣿⣽⣾⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠒⠀⠀⠀⠀⠀⠾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣽⣿⣿⣯⣿⣿⢷⣿⣻⣽⣿⣯⣿⡇⠀⠀⠀⠀⠉⠢⣄⠀⠀⠀⠀⢄⠫⡼⣱",
"⠀⠀⠀⠀⠀⠀⣰⠏⢀⣠⢔⡋⠀⣀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣻⣽⣾⢿⣽⣾⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡎⢸⣿⣯⣿⣿⣿⣿⣾⢿⣻⣿⣽⣿⣿⣽⣿⠀⠀⠀⠀⠀⣠⢼⠗⣤⠀⠀⢀⢣⢳⡱",
"⠀⠀⠀⠀⠀⡴⠃⡨⠏⣡⣫⠔⠋⠁⠀⠀⠀⠀⢰⣿⣿⣿⣷⣿⣻⣽⡿⣯⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢞⠝⣜⣨⣿⣿⣽⣿⣿⣿⣾⡿⣟⣷⡿⣽⣿⡿⣿⠀⠀⠀⡴⠊⠱⢃⣞⠴⡷⣄⠀⢎⠲⣍",
"⠀⠀⠀⠀⡼⠑⣊⠤⢚⡥⣊⡀⠀⠀⠀⡀⠀⠀⢸⣿⣿⣿⡾⣟⣿⣽⣿⣻⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠃⣎⠜⣫⡠⣿⣿⣽⣿⣷⣿⣿⢿⣟⣯⣿⡿⣿⣿⢿⡇⠀⠀⠀⢠⠴⠊⠁⠼⣵⡏⡳⣌⠳⣌",
"⠀⠀⠀⡼⠁⠀⢠⠔⢉⢴⠟⠀⣀⡴⠚⠁⠀⠀⣿⣿⣿⣷⡿⣿⣯⣿⢾⣟⣿⠀⠀⠀⠀⠀⠀⢀⡴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢠⠞⢁⢞⡕⢡⣿⣿⣽⣾⣿⣯⣿⣿⣿⣻⣷⣿⣿⡿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠀⠈⢷⡌",
"⠀⠀⣰⠃⠀⠀⠀⠀⠑⢃⡤⡞⠁⠀⠀⠀⠀⢸⣿⣿⣿⢷⣿⣟⣷⡿⣿⣻⣿⡀⠀⠀⠀⠀⢶⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⣿⡇⢸⣿⡿⣾⣟⣿⣻⣽⣿⣷⣿⣻⣾⢿⣿⣟⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻",
"⠀⢀⠃⠀⠀⠀⢀⡠⠖⣡⢞⠤⠀⠀⠀⠀⢀⣿⣿⣿⣿⣻⣽⣾⣟⣿⣟⣯⣿⣧⠀⠀⠀⠀⠈⢛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠴⠃⠀⠀⠀⠀⠀⠀⠀⠈⠀⣾⣿⣟⣿⣽⣟⣿⣻⣿⣿⢾⡿⣽⣿⣿⡿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
"*/",
"$2",
]
},
"Leetcode Generic Skel": {
  "prefix": "LC",
  "body": [
    "#define FORI for ( int i = 0 ; i < n;i++)",
    "#define FORJ for ( int j = 0 ; j < n;j++)",
    "#define VOUT for(auto it:nums) { cout << it; }",
    "#define pb push_back",
    "#define eb emplace_back",
    "#define all(v) v.begin(), v.end()",
    "#define lb lower_bound",
    "#define ub upper_bound",
    "#define min_heap priority_queue<int, vector<int>, greater<int>>",
    "#define py cout<<\"YES\"<<endl",
    "#define pn cout<<\"NO\"<<endl",
    "typedef long long ll;",
    "const ll mod = 1e9 + 7;",
    "",
    "// Modular Arithmetic Utility Functions",
    "ll mod_pow(ll a, ll b, ll m = mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % m; a = (a * a) % m; b = b >> 1;} return res;}",
    "ll inv_mod(ll a, ll m = mod) {return mod_pow(a, m - 2, m);} //For prime mod",
    "ll mod_add(ll a, ll b, ll m = mod) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
    "ll mod_sub(ll a, ll b, ll m = mod) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
    "ll mod_mul(ll a, ll b, ll m = mod) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}",
    "ll mod_div(ll a, ll b, ll m = mod) {a = a % m; b = b % m; return mod_mul(a, inv_mod(b, m), m);}",
    "",
    "//Predefined Functions",
    "#define prime(n) ([](int num){ if(num <= 1) return false;for(int i=2; i*i <= num; ++i) if(num % i == 0) return false;return true;}(n))",
    "#define primef vector<int> factors(int n) { vector<int> f; for (int x = 2; x*x <= n; x++) {while (n%x == 0) {f.push_back(x);n /= x;}}if (n > 1) f.push_back(n);return f;}",
    "#define gcd(a, b) ((b) == 0 ? (a) : gcd((b), (a) % (b)))",
    "",
    "$2",
  ],
  "description": ""
},
"For FAST IO in Leetcode": {
  "prefix": "FAST IO LC",
  "body": [
    "static const int kds = []() {",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "    cout.tie(nullptr);",
    "    return 0;",
    "}()"
  ],
  "description": "For FAST IO in Leetcode"
},
"To find the nCr": {
  "prefix": "nCr",
  "body": [
    "long long nCr(int n, int r) {",
    "    long long res = 1;",
    "    for (int i = 0; i < r; i++) {",
    "        res *= (n - i);",
    "        res /= (i + 1);",
    "    }",
    "    return res;",
    "}",
  ],
},
"For Disjoin Set Union": {
  "prefix": "DSU",
  "body": [
    "// DSU",
    "class DSU {",
    "    vector<int> parent, size, rank;",
    "",
    "public:",
    "    DSU(int n) {",
    "        for(int i = 0; i < n + 1; i++) {",
    "            size.push_back(1);",
    "            parent.push_back(i);",
    "            rank.push_back(0);",
    "        }",
    "    }",
    "",
    "    int findParent(int node) {",
    "        if (parent[node] == node) {",
    "            return node;",
    "        }",
    "        return parent[node] = findParent(parent[node]);",
    "    }",
    "",
    "    void unionSize(int u, int v) {",
    "        int pu = findParent(u);",
    "        int pv = findParent(v);",
    "",
    "        if (pu == pv) {",
    "            return;",
    "        }",
    "        if (size[pu] < size[pv]) {",
    "            parent[pu] = pv;",
    "            size[pv] += size[pu];",
    "        } else {",
    "            parent[pv] = pu;",
    "            size[pu] += size[pv];",
    "        }",
    "    }",
    "",
    "    void unionRank(int u, int v) {",
    "        int pu = findParent(u);",
    "        int pv = findParent(v);",
    "",
    "        if (pu == pv) {",
    "            return;",
    "        }",
    "        if (rank[pu] == rank[pv]) {",
    "            parent[pu] = pv;",
    "            rank[pu]++;",
    "        }",
    "        else if (rank[pu] < rank[pv]) {",
    "            parent[pu] = pv;",
    "        }",
    "        else {",
    "            parent[pv] = pu;",
    "        }",
    "    }",
    "",
    "    // To find the size of the component of any vertex u, use its parent not the vertex u itself.",
    "    int findSize(int n) {",
    "        return size[n];",
    "    }",
    "};",
  ],
  "description": "For Disjoin Set Union"
},
"Modular Int Operations": {
  "prefix": "ModInt",
  "body": [
    "struct ModInt {",
    "    static const int mod = 1e9+7; // MAKE SURE TO RECHECK THIS",
    "    long long val;",
    "",
    "    ModInt(long long v = 0) { ",
    "        val = v % mod; ",
    "        if (val < 0) val += mod; ",
    "    }",
    "",
    "    ModInt operator+(const ModInt &o) const { return ModInt(val + o.val); }",
    "    ModInt operator-(const ModInt &o) const { return ModInt(val - o.val); }",
    "    ModInt operator*(const ModInt &o) const { return ModInt(val * o.val); }",
    "    ModInt operator/(const ModInt &o) const { return *this * o.inv(); }",
    "",
    "    ModInt pow(long long b) const {",
    "        ModInt res(1), a(val);",
    "        while (b) {",
    "            if (b & 1) res = res * a;",
    "            a = a * a;",
    "            b >>= 1;",
    "        }",
    "        return res;",
    "    }",
    "",
    "    ModInt inv() const { return pow(mod - 2); }",
    "",
    "    // for cin/cout",
    "    friend ostream& operator<<(ostream &os, const ModInt &m) {",
    "        return os << m.val;",
    "    }",
    "    friend istream& operator>>(istream &is, ModInt &m) {",
    "        long long v; is >> v;",
    "        m = ModInt(v);",
    "        return is;",
    "    }",
    "};",
    ""
  ],
  "description": "Modular Int Operations"
},
"Snippet for debugging": {
  "prefix": "Debugging",
  "body": [
    "// <------------------------------------Debugging Macros for Conditional Output during Development---------------------------------->",
    "#ifndef ONLINE_JUDGE",
    "    #define debug(x)        cerr << #x << \" = \" << (x) << \"\\n\"",
    "    #define debug_pair(p)   cerr << #p << \" = (\" << (p).first << \", \" << (p).second << \")\\n\"",
    "    #define debug_vec(v)    do {                                          \\",
    "                             cerr << #v << \" = [\";                       \\",
    "                             for (auto& _e : (v))                       \\",
    "                                 cerr << _e << \", \";                      \\",
    "                             cerr << \"]\\n\";                              \\",
    "                          } while (0)",
    "    #define debug_map(m)    do {                                          \\",
    "                             cerr << #m << \" = {\";                       \\",
    "                             for (auto& _kv : (m))                      \\",
    "                                 cerr << \"(\" << _kv.first                \\",
    "                                      << \":\" << _kv.second << \"), \";      \\",
    "                             cerr << \"}\\n\";                              \\",
    "                          } while (0)",
    "#else",
    "    #define debug(x)        do {} while (0)",
    "    #define debug_pair(p)   do {} while (0)",
    "    #define debug_vec(v)    do {} while (0)",
    "    #define debug_map(m)    do {} while (0)",
    "#endif",
    "// <------------------------------------------------------Debugging ends --------------------------------------------------------->"
  ],
  "description": "Snippet for debugging"
},
"Templates for code writing": {
  "prefix": "Templates",
  "body": [
    "#define ya ios_base::sync_with_stdio(false);",
    "#define sudi cin.tie(nullptr);",
    "#define balle_balle cout.tie(nullptr);",
    "#define FORI for (int i = 0; i < n; i++)",
    "#define FORJ for (int j = 0; j < n; j++)",
    "#define FOR(a, b, x) for (int a = b; a < x; a++)",
    "#define VOUT for(auto it:nums){ cout << it; }",
    "#define pb emplace_back",
    "#define all(x) x.begin(), x.end()",
    "#define int int64_t",
    "#define ld long double",
    "using i64 = int64_t;",
    "using i128 = __int128_t;",
    "#define lb lower_bound",
    "#define ub upper_bound",
    "#define min_heap priority_queue<int, vector<int>, greater<int>>",
    "#define min_heap_pair priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>",
    "#define minh_heap_tuple priority_queue<tuple<ll,int,int>,vector<tuple<ll,int,int>>,greater<tuple<ll,int,int>>>",
    "#define py cout<<\"YES\"<<endl",
    "#define pn cout<<\"NO\"<<endl",
    "#define endl \"\\n\"",
    "#define ps(x,y) fixed<<setprecision(y)<<x",
    "#define numtobin(n) bitset<32>(n).to_string()",
    "#define vi vector<int>",
    "#define vll vector<long long>",
    "#define vvi vector<vector<int>>",
    "#define vb vector<bool>",
    "#define vc vector<char>",
    "#define vs vector<string>",
    "#define pii pair<int,int>",
    "#define vpii vector<pair<int,int>>",
    "#define si set<int>",
    "#define ff first",
    "#define ss second",
    "#define POPCOUNT(x) (__builtin_popcountll(x)) // counts number of 1 / set bits in x ",
    "#define CLZ(x) (__builtin_clzll(x))           // counts leading 0s in x (before first 1 from MSB)",
    "#define CTZ(x) (__builtin_ctzll(x))           // counts trailing 0s in x (after last 1 from LSB)",
    "using ll = long long;",
    "const ll mod = 1e9 + 7;",
    "const int INF = 1e15;",
    ""
  ],
  "description": "Templates for code writing"
},

"Modular Functions": {
  "prefix": "Mod functions",
  "body": [
    "long long mod_pow(long long a, long long b, long long m = mod) {",
    "    long long res = 1;",
    "    while (b) {",
    "        if (b & 1) res = (res * a) % m;",
    "        a = (a * a) % m;",
    "        b >>= 1;",
    "    }",
    "    return res;",
    "}",
    "",
    "long long mod_inv(long long a, long long m = mod) {",
    "    return mod_pow(a, m - 2, m);",
    "}",
    "",
    "long long mod_add(long long a, long long b, long long m = mod) {",
    "    return ((a % m + b % m) % m + m) % m;",
    "}",
    "",
    "long long mod_sub(long long a, long long b, long long m = mod) {",
    "    return ((a % m - b % m) % m + m) % m;",
    "}",
    "",
    "long long mod_mul(long long a, long long b, long long m = mod) {",
    "    return ((a % m) * (b % m)) % m;",
    "}",
    "",
    "long long mod_div(long long a, long long b, long long m = mod) {",
    "    return mod_mul(a, mod_inv(b, m), m);",
    "}"
  ],
  "description": "Modular Functions"
},
"Safe hash map to avoid collisions": {
  "prefix": "safe map",
  "body": [
    "// Custom hash function",
    "struct custom_hash {",
    "    static uint64_t splitmix64(uint64_t x) noexcept {",
    "        x += 0x9e3779b97f4a7c15ULL;",
    "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9ULL;",
    "        x = (x ^ (x >> 27)) * 0x94d049bb133111ebULL;",
    "        return x ^ (x >> 31);",
    "    }",
    "",
    "    // base uint64_t entrypoint",
    "    size_t operator()(uint64_t x) const noexcept {",
    "        static const uint64_t FIXED_RANDOM =",
    "            chrono::steady_clock::now().time_since_epoch().count();",
    "        return (size_t)splitmix64(x + FIXED_RANDOM);",
    "    }",
    "",
    "    // generic fallback for types that have std::hash<T>",
    "    template<typename T>",
    "    size_t operator()(const T &x) const noexcept {",
    "        return (*this)(static_cast<uint64_t>(std::hash<T>{}(x)));",
    "    }",
    "",
    "    // pair<K,V> overload (so pair<int,int> works even though std::hash<pair<..>> is not standard)",
    "    template<typename A, typename B>",
    "    size_t operator()(const pair<A,B> &p) const noexcept {",
    "        uint64_t h1 = uint64_t(std::hash<A>{}(p.first));",
    "        uint64_t h2 = uint64_t(std::hash<B>{}(p.second));",
    "        // combine like boost::hash_combine, then feed to splitmix",
    "        uint64_t combined = h1 ^ (h2 + 0x9e3779b97f4a7c15ULL + (h1<<6) + (h1>>2));",
    "        return (*this)(combined);",
    "    }",
    "};",
    "",
    "template<typename K, typename V>",
    "using umap = unordered_map<K, V, custom_hash>;"
  ],
  "description": "Safe hash map to avoid collisions"
},
"For problems dealing with mex": {
  "prefix": "Mex",
  "body": [
    "struct Mex {",
    "    set<int> missing;               // Stores all potential mex values",
    "    unordered_map<int, int> freq;   // Frequency of each element in the current set",
    "",
    "    // Initialize with numbers from 0 to n + 1 -> O(n log n) time taken.",
    "    Mex(int n) {",
    "        for (int i = 0; i <= n + 1; i++) ",
    "            missing.insert(i);",
    "    }",
    "",
    "    // Add an element to the set",
    "    void add(int x) {",
    "        if (++freq[x] == 1)          ",
    "            missing.erase(x);        // Remove from potential mex",
    "    }",
    "",
    "    // Remove an element from the set",
    "    void remove(int x) {",
    "        if (--freq[x] == 0)       ",
    "            missing.insert(x);       // Reinsert into potential mex",
    "    }",
    "",
    "    // Get current mex",
    "    int get() const {",
    "        return *missing.begin();",
    "    }",
    "};"
  ],
  "description": "For problems dealing with mex"
},
"Kruskal's Minimum Spanning Tree": {
  "prefix": "mst kruskal",
  "body": [
    "// Kruskal's Minimum Spanning Tree",
    "// edges format: vector<vector<int>> edges -> {u, v, weight}",
    "// Convert all long doubles to int if you want answer without floating points",
    "vector<vector<int>> mstEdges;",
    "",
    "int kruskalMST(int vertexCount, vector<vector<int>> &edges) {",
    "    sort(edges.begin(), edges.end(), [](const vector<int> &a, const vector<int> &b) {",
    "        return a[2] < b[2];",
    "    });",
    "",
    "    DSU dsu(vertexCount);",
    "    int totalWeight = 0;",
    "    mstEdges.clear();",
    "",
    "    int usedEdges = 0;",
    "    for (auto &e : edges) {",
    "        int u = e[0], v = e[1], w = e[2];",
    "        if (dsu.findParent(u) != dsu.findParent(v)) {",
    "            dsu.unionSize(u, v);",
    "            totalWeight += w;",
    "            mstEdges.push_back(e);",
    "            if (++usedEdges == vertexCount - 1) break;",
    "        }",
    "    }",
    "",
    "    return totalWeight;",
    "}",
    "",
  ],
},
"Sieve of Eratosthenes": {
  "prefix": "sieve_of_eratosthenes",
  "body": [
    "vector<bool> SieveOfEratosthenes(long long n) {",
    "    vector<bool> prime(n + 1, true);",
    "    prime[0] = prime[1] = false;",
    "    for (long long p = 2; p * p <= n; ++p) {",
    "        if (prime[p]) {",
    "            for (long long i = p * p; i <= n; i += p)",
    "                prime[i] = false;",
    "        }",
    "    }",
    "    return prime;",
    "}"
  ],
  "description": "Sieve of Eratosthenes"
},
"PBDS Template": {
  "prefix": "pbds",
  "body": [
    "// Policy Based Data Structures (PBDS)",
    "#undef int // disables above #define int ll temporarily",
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "#include <ext/pb_ds/priority_queue.hpp>",
    "#define int long long",
    "",
    "using namespace __gnu_pbds;",
    "",
    "// Ordered Set",
    "// Use find_by_order(k) to get an iterator to the k-th (0-indexed) smallest element",
    "// Use order_of_key(k) to get count of elements < x",
    "template <typename T>",
    "using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    "",
    "// Ordered multiset (allow duplicates) - store (value, unique_id)",
    "// Use emplace({val, unique_id}) and order_of_key({x+1, MIN_ID}) to count <= x",
    "template <typename T>",
    "using ordered_multiset = tree< pair<T,int>, null_type, less<pair<T,int>>, rb_tree_tag, tree_order_statistics_node_update>;",
    "",
    "// Ordered map (order statistics on keys)",
    "// Use find_by_order(k) to get k-th key; order_of_key(key) counts keys < key",
    "template <typename Key, typename Mapped>",
    "using ordered_map = tree< Key, Mapped, less<Key>, rb_tree_tag, tree_order_statistics_node_update>;",
    "",
    "// gp_hash_table (fast hash map) - similar API to unordered_map",
    "// Example: gp_hash_table<long long,int> gph;",
    "template <typename K, typename V>",
    "using gp_hash_table = cc_hash_table<K, V>;",
    "",
    "/*",
    "Quick usage notes:",
    "    - ordered_set<int> os; os.insert(x); os.order_of_key(x); os.find_by_order(k);",
    "    - ordered_multiset<long long> oms; int uid=0; oms.insert({val, uid++}); oms.order_of_key({val+1, PAIR_MIN});",
    "    - ordered_map<Key,Value> om; om.insert({k,v}); om.order_of_key(k);",
    "    - gp_hash_table<K,V> gph; gph.emplace(k,v); gph.find(k);",
    "*/"
  ],
  "description": "PBDS Template"
},
"Miller Rabin Primality Test": {
  "prefix": "miller_rabin",
  "body": [
    "// Miller-Rabin Primality Test [Deterministic for 64-bit numbers]",
    "// Time Complexity: O(log n)",
    "int binpower(int base, int e, int mod) { ",
    "    int result = 1;",
    "    base %= mod;",
    "    while (e) {",
    "        if (e & 1)",
    "            result = (__int128_t)result * base % mod;",
    "        base = (__int128_t)base * base % mod;",
    "        e >>= 1;",
    "    }",
    "    return result;",
    "}",
    "",
    "bool check_composite(int n, int a, int d, int s) {",
    "    int x = binpower(a, d, n);",
    "    if (x == 1 || x == n - 1)",
    "        return false;",
    "    for (int r = 1; r < s; r++) {",
    "        x = (__int128_t)x * x % n;",
    "        if (x == n - 1)",
    "            return false;",
    "    }",
    "    return true;",
    "};",
    "",
    "bool MillerRabin(int n) { // returns true if n is prime, else returns false.",
    "    if (n < 2)",
    "        return false;",
    "",
    "    int r = 0;",
    "    int d = n - 1;",
    "    while ((d & 1) == 0) {",
    "        d >>= 1;",
    "        r++;",
    "    }",
    "",
    "    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
    "        if (n == a)",
    "            return true;",
    "        if (check_composite(n, a, d, r))",
    "            return false;",
    "    }",
    "    return true;",
    "}"
  ],
  "description": "Miller Rabin Primality Test"
},
"Mobius Function Computation": {
  "prefix": "mobius_function",
  "body": [
    "// Möbius Function Computation",
    "// Time Complexity: O(n log log n)",
    "void computeMobius(int n, vector<int>& mu) {",
    "    vector<int> is_prime(n + 1, 1);",
    "    mu[0] = 0;",
    "    mu[1] = 1;",
    "",
    "    for (int i = 2; i <= n; ++i) {",
    "        if (is_prime[i]) {",
    "            for (int j = i; j <= n; j += i) {",
    "                mu[j] *= -1;",
    "                is_prime[j] = 0;",
    "            }",
    "",
    "            for (int j = i * i; j <= n; j += i * i) {",
    "                mu[j] = 0; ",
    "            }",
    "        }",
    "    }",
    "}",
    ""
  ],
  "description": "Mobius Function Computation"
},
"Segment Tree for sum queries": {
  "prefix": "Segment_Tree_Sum",
  "body": [
    "class SegmentTree_Sum {",
    "public:",
    "    int n;",
    "    vector<long long> tree, lazy;",
    "",
    "    SegmentTree_Sum(int n) : n(n) {",
    "        tree.assign(4 * n, 0);",
    "        lazy.assign(4 * n, 0);",
    "    }",
    "",
    "    // For building the tree from an array ",
    "    // Time Complexity: O(n)",
    "    void build(const vector<long long> &a, int node, int start, int end) {",
    "        if (start == end) {",
    "            tree[node] = a[start];",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        build(a, node * 2, start, mid);",
    "        build(a, node * 2 + 1, mid + 1, end);",
    "        tree[node] = tree[node * 2] + tree[node * 2 + 1];",
    "    }",
    "",
    "    // Used for applying a lazy update to a node",
    "    // Time Complexity: O(1)",
    "    void apply(int node, int start, int end, long long val) {",
    "        tree[node] += 1LL * (end - start + 1) * val;",
    "        lazy[node] += val;",
    "    }",
    "",
    "    // Used for pushing pending lazy updates to children",
    "    // Time Complexity: O(1)",
    "    void push(int node, int start, int end) {",
    "        if (lazy[node] == 0) return;",
    "        int mid = (start + end) / 2;",
    "        apply(node * 2, start, mid, lazy[node]);",
    "        apply(node * 2 + 1, mid + 1, end, lazy[node]);",
    "        lazy[node] = 0;",
    "    }",
    "",
    "    // Used for updating range [l, r] by adding val",
    "    // Time Complexity: O(log n)",
    "    void updateRange(int node, int start, int end, int l, int r, long long val) {",
    "        if (l > r) return;",
    "        if (l == start && r == end) {",
    "            apply(node, start, end, val);",
    "            return;",
    "        }",
    "        push(node, start, end);",
    "        int mid = (start + end) / 2;",
    "        updateRange(node * 2, start, mid, l, min(r, mid), val);",
    "        updateRange(node * 2 + 1, mid + 1, end, max(l, mid + 1), r, val);",
    "        tree[node] = tree[node * 2] + tree[node * 2 + 1];",
    "    }",
    "",
    "    // Used for finding Range Sum in [l, r]",
    "    // Time Complexity: O(log n)",
    "    long long query(int node, int start, int end, int l, int r) {",
    "        if (l > r) return 0;",
    "        if (l == start && r == end) return tree[node];",
    "        push(node, start, end);",
    "        int mid = (start + end) / 2;",
    "        return query(node * 2, start, mid, l, min(r, mid))",
    "             + query(node * 2 + 1, mid + 1, end, max(l, mid + 1), r);",
    "    }",
    "};"
  ],
  "description": "Segment Tree for sum queries"
},
"2nd Segment Tree": {
  "prefix": "SegmentTree_Sum_2",
  "body": [
    "class SegmentTree_Sum {",
    "public:",
    "    int n;",
    "    vector<long long> tree, lazy_add, lazy_set;",
    "    vector<bool> has_set;",
    "",
    "    SegmentTree_Sum(int n) : n(n) {",
    "        tree.assign(4 * n, 0);",
    "        lazy_add.assign(4 * n, 0);",
    "        lazy_set.assign(4 * n, 0);",
    "        has_set.assign(4 * n, false);",
    "    }",
    "",
    "    void build(const vector<long long> &a, int node, int start, int end) {",
    "        if (start == end) {",
    "            tree[node] = a[start];",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        build(a, node * 2, start, mid);",
    "        build(a, node * 2 + 1, mid + 1, end);",
    "        tree[node] = tree[node * 2] + tree[node * 2 + 1];",
    "    }",
    "",
    "    void apply_add(int node, int start, int end, long long val) {",
    "        if (has_set[node]) lazy_set[node] += val;",
    "        else lazy_add[node] += val;",
    "        tree[node] += 1LL * (end - start + 1) * val;",
    "    }",
    "",
    "    void apply_set(int node, int start, int end, long long val) {",
    "        tree[node] = 1LL * (end - start + 1) * val;",
    "        lazy_set[node] = val;",
    "        lazy_add[node] = 0;",
    "        has_set[node] = true;",
    "    }",
    "",
    "    void push(int node, int start, int end) {",
    "        if (start == end) return;",
    "        int mid = (start + end) / 2;",
    "        if (has_set[node]) {",
    "            apply_set(node * 2, start, mid, lazy_set[node]);",
    "            apply_set(node * 2 + 1, mid + 1, end, lazy_set[node]);",
    "            has_set[node] = false;",
    "        }",
    "        if (lazy_add[node] != 0) {",
    "            apply_add(node * 2, start, mid, lazy_add[node]);",
    "            apply_add(node * 2 + 1, mid + 1, end, lazy_add[node]);",
    "            lazy_add[node] = 0;",
    "        }",
    "    }",
    "",
    "    void updateAdd(int node, int start, int end, int l, int r, long long val) {",
    "        if (r < start || end < l) return;",
    "        if (l <= start && end <= r) {",
    "            apply_add(node, start, end, val);",
    "            return;",
    "        }",
    "        push(node, start, end);",
    "        int mid = (start + end) / 2;",
    "        updateAdd(node * 2, start, mid, l, r, val);",
    "        updateAdd(node * 2 + 1, mid + 1, end, l, r, val);",
    "        tree[node] = tree[node * 2] + tree[node * 2 + 1];",
    "    }",
    "",
    "    void updateSet(int node, int start, int end, int l, int r, long long val) {",
    "        if (r < start || end < l) return;",
    "        if (l <= start && end <= r) {",
    "            apply_set(node, start, end, val);",
    "            return;",
    "        }",
    "        push(node, start, end);",
    "        int mid = (start + end) / 2;",
    "        updateSet(node * 2, start, mid, l, r, val);",
    "        updateSet(node * 2 + 1, mid + 1, end, l, r, val);",
    "        tree[node] = tree[node * 2] + tree[node * 2 + 1];",
    "    }",
    "",
    "    long long queryRange(int node, int start, int end, int l, int r) {",
    "        if (r < start || end < l) return 0;",
    "        if (l <= start && end <= r) return tree[node];",
    "        push(node, start, end);",
    "        int mid = (start + end) / 2;",
    "        return queryRange(node * 2, start, mid, l, r)",
    "             + queryRange(node * 2 + 1, mid + 1, end, l, r);",
    "    }",
    "};"
  ],
  "description": "2nd Segment Tree"
},
"Segment Tree for min queries": {
  "prefix": "Segment_Tree_Min",
  "body": [
    "class SegmentTree_Min {",
    "public:",
    "    int n;",
    "    vector<long long> tree;",
    "",
    "    SegmentTree_Min(int n) : n(n) {",
    "        tree.assign(4 * n, 1e18);",
    "    }",
    "",
    "    // Build the tree from an array",
    "    // Time Complexity: O(n)",
    "    void build(const vector<long long> &a, int node, int start, int end) {",
    "        if (start == end) {",
    "            tree[node] = a[start];",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        build(a, node * 2, start, mid);",
    "        build(a, node * 2 + 1, mid + 1, end);",
    "        tree[node] = min(tree[node * 2], tree[node * 2 + 1]);",
    "    }",
    "",
    "    // Point update: set position idx to val",
    "    // Time Complexity: O(log n)",
    "    void update(int node, int start, int end, int idx, long long val) {",
    "        if (start == end) {",
    "            tree[node] = val;",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        if (idx <= mid) update(node * 2, start, mid, idx, val);",
    "        else update(node * 2 + 1, mid + 1, end, idx, val);",
    "        tree[node] = min(tree[node * 2], tree[node * 2 + 1]);",
    "    }",
    "",
    "    // Query min in range [l, r]",
    "    // Time Complexity: O(log n)",
    "    long long query(int node, int start, int end, int l, int r) {",
    "        if (l > r) return 1e18;",
    "        if (l == start && r == end) return tree[node];",
    "        int mid = (start + end) / 2;",
    "        return min(",
    "            query(node * 2, start, mid, l, min(r, mid)),",
    "            query(node * 2 + 1, mid + 1, end, max(l, mid + 1), r)",
    "        );",
    "    }",
    "};",
    ""
  ],
  "description": "Segment Tree for min queries"
},
"Segment Tree for max queries": {
  "prefix": "Segment_Tree_Max",
  "body": [
    "class SegmentTree_Max {",
    "public:",
    "    int n;",
    "    vector<long long> tree;",
    "",
    "    SegmentTree_Max(int n) : n(n) {",
    "        tree.assign(4 * n, -1e18);",
    "    }",
    "",
    "    // Build the tree from an array",
    "    // Time Complexity: O(n)",
    "    void build(const vector<long long> &a, int node, int start, int end) {",
    "        if (start == end) {",
    "            tree[node] = a[start];",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        build(a, node * 2, start, mid);",
    "        build(a, node * 2 + 1, mid + 1, end);",
    "        tree[node] = max(tree[node * 2], tree[node * 2 + 1]);",
    "    }",
    "",
    "    // Point update: set position idx to val",
    "    // Time Complexity: O(log n)",
    "    void update(int node, int start, int end, int idx, long long val) {",
    "        if (start == end) {",
    "            tree[node] = val;",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        if (idx <= mid) update(node * 2, start, mid, idx, val);",
    "        else update(node * 2 + 1, mid + 1, end, idx, val);",
    "        tree[node] = max(tree[node * 2], tree[node * 2 + 1]);",
    "    }",
    "",
    "    // Query max in range [l, r]",
    "    // Time Complexity: O(log n)",
    "    long long query(int node, int start, int end, int l, int r) {",
    "        if (l > r) return -1e18;",
    "        if (l == start && r == end) return tree[node];",
    "        int mid = (start + end) / 2;",
    "        return max(",
    "            query(node * 2, start, mid, l, min(r, mid)),",
    "            query(node * 2 + 1, mid + 1, end, max(l, mid + 1), r)",
    "        );",
    "    }",
    "};",
    ""
  ],
  "description": "Segment Tree for max queries"
},
"Segment Tree for xor queries": {
  "prefix": "Segment_Tree_Xor",
  "body": [
    "class SegmentTree_XOR {",
    "public:",
    "    int n;",
    "    vector<long long> tree;",
    "",
    "    SegmentTree_XOR(int n) : n(n) {",
    "        tree.assign(4 * n, 0);",
    "    }",
    "",
    "    // Build the tree from an array",
    "    // Time Complexity: O(n)",
    "    void build(const vector<long long> &a, int node, int start, int end) {",
    "        if (start == end) {",
    "            tree[node] = a[start];",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        build(a, node * 2, start, mid);",
    "        build(a, node * 2 + 1, mid + 1, end);",
    "        tree[node] = tree[node * 2] ^ tree[node * 2 + 1];",
    "    }",
    "",
    "    // Point update: set position idx to val",
    "    // Time Complexity: O(log n)",
    "    void update(int node, int start, int end, int idx, long long val) {",
    "        if (start == end) {",
    "            tree[node] = val;",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        if (idx <= mid) update(node * 2, start, mid, idx, val);",
    "        else update(node * 2 + 1, mid + 1, end, idx, val);",
    "        tree[node] = tree[node * 2] ^ tree[node * 2 + 1];",
    "    }",
    "",
    "    // Query XOR in range [l, r]",
    "    // Time Complexity: O(log n)",
    "    long long query(int node, int start, int end, int l, int r) {",
    "        if (l > r) return 0;",
    "        if (l == start && r == end) return tree[node];",
    "        int mid = (start + end) / 2;",
    "        return query(node * 2, start, mid, l, min(r, mid))",
    "             ^ query(node * 2 + 1, mid + 1, end, max(l, mid + 1), r);",
    "    }",
    "};",
    ""
  ],
  "description": "Segment Tree for xor queries"
},
"Segment Tree for gcd queries": {
  "prefix": "Segment_Tree_GCD",
  "body": [
    "class SegmentTree_GCD {",
    "public:",
    "    int n;",
    "    vector<long long> tree;",
    "",
    "    SegmentTree_GCD(int n) : n(n) {",
    "        tree.assign(4 * n, 0); // neutral element = 0",
    "    }",
    "",
    "    // Build tree from array",
    "    // Time Complexity: O(n)",
    "    void build(const vector<long long> &a, int node, int start, int end) {",
    "        if (start == end) {",
    "            tree[node] = a[start];",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        build(a, node * 2, start, mid);",
    "        build(a, node * 2 + 1, mid+1, end);",
    "        tree[node] = gcd(tree[node * 2], tree[node * 2 + 1]);",
    "    }",
    "",
    "    // Point update: set idx to val",
    "    // Time Complexity: O(log n)",
    "    void update(int node, int start, int end, int idx, long long val) {",
    "        if (start == end) {",
    "            tree[node] = val;",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        if (idx <= mid) update(node * 2, start, mid, idx, val);",
    "        else update(node * 2 + 1, mid + 1, end, idx, val);",
    "        tree[node] = gcd(tree[node * 2], tree[node * 2 + 1]);",
    "    }",
    "",
    "    // Query GCD in range [l, r]",
    "    // Time Complexity: O(log n)",
    "    long long query(int node, int start, int end, int l, int r) {",
    "        if (l > r) return 0;",
    "        if (l == start && r == end) return tree[node];",
    "        int mid = (start + end) / 2;",
    "        return std::gcd(",
    "            query(node * 2, start, mid, l, min(r, mid)),",
    "            query(node * 2 + 1, mid + 1, end, max(l, mid + 1), r)",
    "        );",
    "    }",
    "};"
  ],
  "description": "Segment Tree for gcd queries"
},
"Segment Tree for lcm queries": {
  "prefix": "Segment_Tree_LCM",
  "body": [
    "class SegmentTree_LCM {",
    "public:",
    "    int n;",
    "    vector<long long> tree;",
    "",
    "    SegmentTree_LCM(int n) : n(n) {",
    "        tree.assign(4 * n, 1); // neutral element = 1",
    "    }",
    "",
    "    long long lcm(long long a, long long b) {",
    "        if (a == 0 || b == 0) return 0;",
    "        return a / gcd(a, b) * b;",
    "    }",
    "",
    "    // Build tree from array",
    "    // Time Complexity: O(n)",
    "    void build(const vector<long long> &a, int node, int start, int end) {",
    "        if (start == end) {",
    "            tree[node] = a[start];",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        build(a, node * 2, start, mid);",
    "        build(a, node * 2 + 1, mid+1, end);",
    "        tree[node] = lcm(tree[node * 2], tree[node * 2 + 1]);",
    "    }",
    "",
    "    // Point update: set idx to val",
    "    // Time Complexity: O(log n)",
    "    void update(int node, int start, int end, int idx, long long val) {",
    "        if (start == end) {",
    "            tree[node] = val;",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        if (idx <= mid) update(node * 2, start, mid, idx, val);",
    "        else update(node * 2 + 1, mid + 1, end, idx, val);",
    "        tree[node] = lcm(tree[node * 2], tree[node * 2 + 1]);",
    "    }",
    "",
    "    // Query LCM in range [l, r]",
    "    // Time Complexity: O(log n)",
    "    long long query(int node, int start, int end, int l, int r) {",
    "        if (l > r) return 1;",
    "        if (l == start && r == end) return tree[node];",
    "        int mid = (start + end) / 2;",
    "        return lcm(",
    "            query(node*2, start, mid, l, min(r, mid)),",
    "            query(node*2+1, mid+1, end, max(l, mid + 1), r)",
    "        );",
    "    }",
    "};"
  ],
  "description": "Segment Tree for lcm queries"
},
"Segment Tree for or queries": {
  "prefix": "Segment_Tree_OR",
  "body": [
    "class SegmentTree_OR {",
    "public:",
    "    int n;",
    "    vector<long long> tree;",
    "",
    "    SegmentTree_OR(int n) : n(n) {",
    "        tree.assign(4 * n, 0); // neutral element = 0",
    "    }",
    "",
    "    // Build tree from array",
    "    // Time Complexity: O(n)",
    "    void build(const vector<long long> &a, int node, int start, int end) {",
    "        if (start == end) {",
    "            tree[node] = a[start];",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        build(a, node * 2, start, mid);",
    "        build(a, node * 2 + 1, mid + 1, end);",
    "        tree[node] = tree[node * 2] | tree[node * 2 + 1];",
    "    }",
    "",
    "    // Point update: set idx to val",
    "    // Time Complexity: O(log n)",
    "    void update(int node, int start, int end, int idx, long long val) {",
    "        if (start == end) {",
    "            tree[node] = val;",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        if (idx <= mid) update(node * 2, start, mid, idx, val);",
    "        else update(node * 2 + 1, mid + 1, end, idx, val);",
    "        tree[node] = tree[node * 2] | tree[node * 2 + 1];",
    "    }",
    "",
    "    // Query OR in range [l, r]",
    "    // Time Complexity: O(log n)",
    "    long long query(int node, int start, int end, int l, int r) {",
    "        if (l > r) return 0;",
    "        if (l == start && r == end) return tree[node];",
    "        int mid = (start + end) / 2;",
    "        return query(node * 2, start, mid, l, min(r, mid))",
    "             | query(node * 2 + 1, mid + 1, end, max(l, mid + 1), r);",
    "    }",
    "};"
  ],
  "description": "Segment Tree for or queries"
},
"Segment Tree for and queries": {
  "prefix": "Segment_Tree_AND",
  "body": [
    "class SegmentTree_AND {",
    "public:",
    "    int n;",
    "    vector<long long> tree;",
    "",
    "    SegmentTree_AND(int n) : n(n) {",
    "        tree.assign(4 * n, (1LL << 60) - 1);",
    "    }",
    "",
    "    // Build tree from array",
    "    // Time Complexity: O(n)",
    "    void build(const vector<long long> &a, int node, int start, int end) {",
    "        if (start == end) {",
    "            tree[node] = a[start];",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        build(a, node * 2, start, mid);",
    "        build(a, node * 2 + 1, mid+1, end);",
    "        tree[node] = tree[node * 2] & tree[node * 2 + 1];",
    "    }",
    "",
    "    // Point update: set idx to val",
    "    // Time Complexity: O(log n)",
    "    void update(int node, int start, int end, int idx, long long val) {",
    "        if (start == end) {",
    "            tree[node] = val;",
    "            return;",
    "        }",
    "        int mid = (start + end) / 2;",
    "        if (idx <= mid) update(node * 2, start, mid, idx, val);",
    "        else update(node * 2 + 1, mid+1, end, idx, val);",
    "        tree[node] = tree[node * 2] & tree[node * 2 + 1];",
    "    }",
    "",
    "    // Query AND in range [l, r]",
    "    // Time Complexity: O(log n)",
    "    long long query(int node, int start, int end, int l, int r) {",
    "        if (l > r) return (1LL << 60) - 1;",
    "        if (l == start && r == end) return tree[node];",
    "        int mid = (start + end) / 2;",
    "        return query(node * 2, start, mid, l, min(r, mid))",
    "             & query(node * 2 + 1, mid + 1, end, max(l, mid + 1), r);",
    "    }",
    "};"
  ],
  "description": "Segment Tree for and queries"
},
"For Meta Hacker Cup": {
  "prefix": "Meta_Hacker_Cup_MHC",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "#define int long long",
    "",
    "// <------------------------------------Debugging Macros for Conditional Output during Development---------------------------------->",
    "#ifndef ONLINE_JUDGE",
    "    #define debug(x)        cerr << #x << \" = \" << (x) << \"\\n\"",
    "    #define debug_pair(p)   cerr << #p << \" = (\" << (p).first << \", \" << (p).second << \")\\n\"",
    "    #define debug_vec(v)    do {                                          \\",
    "                             cerr << #v << \" = [\";                       \\",
    "                             for (auto& _e : (v))                       \\",
    "                                 cerr << _e << \", \";                      \\",
    "                             cerr << \"]\\n\";                              \\",
    "                          } while (0)",
    "    #define debug_map(m)    do {                                          \\",
    "                             cerr << #m << \" = {\";                       \\",
    "                             for (auto& _kv : (m))                      \\",
    "                                 cerr << \"(\" << _kv.first                \\",
    "                                      << \":\" << _kv.second << \"), \";      \\",
    "                             cerr << \"}\\n\";                              \\",
    "                          } while (0)",
    "#else",
    "    #define debug(x)        do {} while (0)",
    "    #define debug_pair(p)   do {} while (0)",
    "    #define debug_vec(v)    do {} while (0)",
    "    #define debug_map(m)    do {} while (0)",
    "#endif",
    "// <------------------------------------------------------Debugging ends --------------------------------------------------------->",
    "",
    "// Problem Statement :",
    "/*",
    "      ",
    "*/",
    "",
    "// Editorial :",
    "/*",
    "    ",
    "*/",
    "",
    "void solve() {",
    "",
    "    $2",
    "",
    "}",
    "",
    "int32_t main() {",
    "    ios_base::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "    cout.tie(nullptr);",
    "",
    "    int t = 1;",
    "    cin >> t;",
    "",
    "    for (int i = 1; i <= t; i++) {",
    "        cout << \"Case #\" << i << \": \";",
    "        solve();",
    "    }",
    "    return 0;",
    "}"
  ],
  "description": "For Meta Hacker Cup"
},
"Usaco Guide Input Output": {
  "prefix": "usaco_guide",
  "body": [
    "freopen(\"input.in\", \"r\", stdin);",
    "freopen(\"output.out\", \"w\", stdout);"
  ],
  "description": "Usaco Guide Input Output"
},
"Feasible LCM Template to avoid overflow.": {
  "prefix": "Feasible_LCM",
  "body": [
    "long long modpow(long long a, long long e, long long mod = 1e9 + 7) {",
    "    long long r = 1;",
    "    while (e) {",
    "        if (e & 1) r = (r * a) % mod;",
    "        a = (a * a) % mod;",
    "        e >>= 1;",
    "    }",
    "    return r;",
    "}",
    "",
    "// Computes LCM of all numbers % mod in a feasible manner to avoid overflows of any kind.",
    "// Time Complexity : O(n * sqrt(max_element(A))",
    "long long lcm_mod(const vector<long long>& arr, long long mod = 1e9 + 7) {",
    "    map<long long, long long> max_pow;",
    "",
    "    for (long long x : arr) {",
    "        long long n = x;",
    "        for (long long p = 2; p * p <= n; p++) {",
    "            if (n % p == 0) {",
    "                long long cnt = 0;",
    "                while (n % p == 0) {",
    "                    n /= p;",
    "                    cnt++;",
    "                }",
    "                max_pow[p] = max(max_pow[p], cnt);",
    "            }",
    "        }",
    "        if (n > 1) {",
    "            max_pow[n] = max(max_pow[n], 1LL);",
    "        }",
    "    }",
    "",
    "    long long ans = 1;",
    "    for (auto &[prime, exp] : max_pow) {",
    "        ans = (ans * modpow(prime % mod, exp)) % mod;",
    "    }",
    "    return ans;",
    "}",
    ""
  ],
  "description": "Feasible LCM Template to avoid overflow."
},
