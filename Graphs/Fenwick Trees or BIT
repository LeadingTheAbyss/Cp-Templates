class FenwickTree {
public:
    int n;
    vector<long long> bit; // 1-indexed tree

    FenwickTree(int n) : n(n) {
        bit.assign(n + 1, 0);
    }

    // BIT from an array in O(n)
    void build(const vector<long long> &a) {
        for (int i = 0; i < n; i++) {
            add(i + 1, a[i]); // 1-indexed
        }
    }

    // Point update: add val to index idx 
    // Time Complexity: O(log n)
    void add(int idx, long long val) {
        while (idx <= n) {
            bit[idx] += val;
            idx += idx & -idx;
        }
    }

    // Prefix sum query: sum of [1, idx]
    // Time Complexity: O(log n)
    long long query(int idx) {
        long long res = 0;
        while (idx > 0) {
            res += bit[idx];
            idx -= idx & -idx;
        }
        return res;
    }

    // Range sum query: sum of [l, r]
    // Time Complexity: O(log n)
    long long query(int l, int r) {
        if (l > r) return 0;
        return query(r) - query(l - 1);
    }

    // Lower Bound: first index such that prefix sum >= x
    // Returns n + 1 if no such index exists
    // Time Complexity: O(log n)
    int lower_bound(long long x) {
        int idx = 0;
        long long sum = 0;
        for (int i = 31 - __builtin_clz(n); i >= 0; i--) {
            int next = idx + (1 << i);
            if (next <= n && sum + bit[next] < x) {
                sum += bit[next];
                idx = next;
            }
        }
        return idx + 1;
    }

    // Range update 
    // Supports adding val to range [l, r]
    // Time Complexity: O(log n)
    void add_range(int l, int r, long long val) {
        add(l, val);
        add(r + 1, -val);
    }
};
