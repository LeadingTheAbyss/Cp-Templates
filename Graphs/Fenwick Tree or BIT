class FenwickTree {
public:
    int n;
    vector<long long> bit; // 0-indexed tree

    FenwickTree(int n) : n(n) {
        bit.assign(n, 0);
    }

    // BIT from an array in O(n)
    void build(const vector<long long> &a) {
        for (int i = 0; i < n; i++) {
            update(i, a[i]); 
        }
    }

    // Point update: add val to index idx (0-indexed)
    // Time Complexity: O(log n)
    void update(int idx, long long val) {
        for (; idx < n; idx = idx | (idx + 1)) {
            bit[idx] += val;
        }
    }

    // Prefix sum query: sum of [0, idx]
    // Time Complexity: O(log n)
    long long query(int idx) {
        long long res = 0;
        for (; idx >= 0; idx = (idx & (idx + 1)) - 1) {
            res += bit[idx];
        }
        return res;
    }

    // Range sum query: sum of [l, r]
    // Time Complexity: O(log n)
    long long query(int l, int r) {
        if (l > r) return 0;
        return query(r) - (l ? query(l - 1) : 0);
    }

    // Lower Bound: first index such that prefix sum >= x
    // Returns n if no such index exists
    // Time Complexity: O(log n)
    int lower_bound(long long x) {
        int idx = -1;
        long long sum = 0;
        for (int i = 31 - __builtin_clz(n); i >= 0; i--) {
            int next = idx + (1 << i);
            if (next < n && sum + bit[next] < x) {
                sum += bit[next];
                idx = next;
            }
        }
        return idx + 1;
    }

    // Range update
    // Supports adding val to range [l, r]
    // Time Complexity: O(log n)
    void add_range(int l, int r, long long val) {
        update(l, val);
        if (r + 1 < n) update(r + 1, -val);
    }
};
